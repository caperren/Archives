\section{Introduction}
Understanding the core constructs of a single operating system is incredibly useful to computer scientists and software developers. Knowing how the system kernel will internally handle a call to open a file, allocate memory, or handle system interrupts allows for more intelligent choices to be made by the programmer so that applications will be more efficient and less likely to crash. It is also incredibly important for security, which is an ever increasing threat in today's world where everything is connected to the Internet. Making a simple choice to use a safer alternative to a particular system call, when you as the developer know that it would leave the computer extra vulnerable in the case where someone bypassed the security of your program, will at minimum minimize potential fallout or in best cases negate the threat completely. Knowing this information about a single operating system is incredibly helpful, but when the world is running on many operating systems it's important to know the similarities and differences between how common features work across a multitude of them. While most programmers in the current age know very little about the underlying hardware they're writing code for, the ones that do have a significant head start in their quest for writing more stable, more secure, and more efficient applications and drivers. This will also be useful to anyone interested in developing kernel modules for Windows or Unix based OS's, or even those interested in doing microcontroller development. With this in mind, this document will cover the basics of process management, I/O, and interrupts in Windows, Linux, and FreeBSD as well as some simple comparisons between their implementations.


\section{Conclusion}
After reviewing the core implementations and features of how Windows, Linux, and FreeBSD handle process, I/O, and interrupts it is easy to see that at their cores every operating system has the same goals in mind. Every system needs certain core features that all have to work in a standardized way (even if it is only to one family of operating systems) so that developers and hardware manufacturers all know what and how they should be developing their applications and how those applications will run. Certain features, like I/O, are vastly different between Windows and Unix based operating systems but still offer similar lower level features such as a hardware abstraction layer, cryptography API, and kernel level queuing of I/O operations. Trade-offs made between these different operating systems are largely subjective and ultimately they all work well, otherwise they wouldn't be as popular as they are. Many programmers will skip out on learning about these low-level features, and for a large percentage of these people, it may never matter. For those wishing to get the best performance, efficiency, and security out of their applications however, a working knowledge of operating systems is a must and the topics covered here are a great start of the many kernel sub-systems that should be studied. This becomes astronomically more important for any computer scientists who end up in a field developing drivers or embedded firmware. 